// TODO
// - MFTを掘り下げる

// MFT Record File Flag
#const global NTFS_FILE_NOT_IN_USE		0
#const global NTFS_FILE_IN_USE			1
#const global NTFS_DIRECTORY_NOT_IN_USE	2
#const global NTFS_DIRECTORY_IN_USE		3
// MFT Attribute Types
#const global NTFS_STANDARD_INFORMATION	0x10
#const global NTFS_ATTRIBUTE_LIST		0x20
#const global NTFS_FILE_NAME			0x30
#const global NTFS_VOLUME_VERSION		0x40
#const global NTFS_OBJECT_ID			0x40
#const global NTFS_SECURITY_DESCRIPTOR	0x50
#const global NTFS_VOLUME_NAME			0x60
#const global NTFS_VOLUME_INFORMATION	0x70
#const global NTFS_DATA					0x80
#const global NTFS_INDEX_ROOT			0x90
#const global NTFS_INDEX_ALLOCATION		0xA0
#const global NTFS_BITMAP				0xB0
#const global NTFS_SYMBOLIC_LINK		0xC0
#const global NTFS_REPARSE_POINT		0xC0
#const global NTFS_EA_INFORMATION		0xD0
#const global NTFS_EA					0xE0
#const global NTFS_LOGGED_UTILITY_STREAM	0x100
// $FILE_NAME Name Space
#const global NTFS_FILE_NAME_POSIX		0
#const global NTFS_FILE_NAME_WIN32		1
#const global NTFS_FILE_NAME_DOS		2
#const global NTFS_FILE_NAME_WIN32_DOS	3

/*--------------------------------------------------
	NTFSブートセクタ構造体
--------------------------------------------------*/
#module st_NTFSBootSector jump, oemID, bytePerSector, sectorPerCluster, reserved,\
                          mediaDescriptor, sectorPerTrack, headNumber, hiddenSector,\
                          totalSector, MFTCluster, MFTMirrCluster, clusterPerRecord, clusterPerBlock,\
                          serialNumber, checkSum, bootCode, endMarker
	// 構造体にコピー
	#modfunc st_NTFSBootSector_SET var buf
		dim jump, 1 : memcpy jump, buf, 3, 0, 0
		dim oemID, 2 : memcpy oemID, buf, 8, 0, 3
		wpoke bytePerSector, 0, wpeek(buf, 0x0B)
		poke sectorPerCluster, 0, peek(buf, 0x0D)
		wpoke reserved, 0, wpeek(buf, 0x0E)
		// unused
		poke mediaDescriptor, 0, peek(buf, 0x15)
		// unused
		wpoke sectorPerTrack, 0, wpeek(buf, 0x18)
		wpoke headNumber, 0, wpeek(buf, 0x1A)
		lpoke hiddenSector, 0, lpeek(buf, 0x1C)
		// unused
		dim totalSector, 2 : memcpy totalSector, buf, 8, 0, 0x28
		dim MFTCluster, 2 : memcpy MFTCluster, buf, 8, 0, 0x30
		dim MFTMirrCluster, 2 : memcpy MFTMirrCluster, buf, 8, 0, 0x38
		poke clusterPerRecord, 0, peek(buf, 0x40)
		// unused(?)
		poke clusterPerBlock, 0, peek(buf, 0x44)
		// unused
		dim serialNumber, 2 : memcpy serialNumber, buf, 8, 0, 0x48
		lpoke checkSum, 0, lpeek(buf, 0x50)
		sdim bootCode, 426 : memcpy bootCode, buf, 426, 0, 0x54
		wpoke endMarker, 0, wpeek(buf, 0x01FE)
	return
	// 構造体から取得
	#modcfunc st_NTFSBootSector_GET str vname
		ret = 0
		switch(getpath(vname, 16))
			case "jump" : memcpy ret, jump, 3, 0, 0 : swbreak
			case "oemid" : ret = varptr(oemID) : swbreak					; 8b
			case "bytepersector" : wpoke ret, 0, bytePerSector : swbreak
			case "sectorpercluster" : poke ret, 0, sectorPerCluster : swbreak
			case "reserved" : wpoke ret, 0, reserved : swbreak
			case "mediadescriptor" : poke ret, 0, mediaDescriptor : swbreak
			case "sectorpertrack" : wpoke buf, 0, sectorPerTrack : swbreak
			case "headnumber" : wpoke buf, 0, headNumber : swbreak
			case "hiddensector" : lpoke buf, 0, hiddenSector : swbreak
			case "totalsector" : ret = varptr(totalSector) : swbreak		; 8b
			case "mftcluster" : ret = varptr(MFTCluster) : swbreak			; 8b
			case "mftmirrcluster" : ret = varptr(MFTMirrCluster) : swbreak	; 8b
			case "clusterperrecord" : poke ret, 0, clusterPerRecord : swbreak
			case "clusterperblock" : poke ret, 0, clusterPerBlock : swbreak
			case "serialnumber" : ret = varptr(serialNumber) : swbreak		; 8b
			case "checksum" : lpoke ret, 0, checkSum : swbreak
			case "bootcode" : ret = varptr(bootCode) : swbreak				; 426b
			case "endmarker" : wpoke ret, 0, endMarker : swbreak
		swend
	return ret
#global

/*--------------------------------------------------
	MFTレコード構造体
--------------------------------------------------*/
#module st_MFTRecord signature, updateOffset, updateNumber, logFile,\
	                 sequenceNumber, hardLinkCount, attributeOffset, flag, usedSize,\
	                 allocatedSize, baseRecord, nextAttributeID, MFTRecord
	#modfunc st_MFTRecord_SET var buf
		lpoke signature, 0, lpeek(buf, 0)
		wpoke updateOffset, 0, wpeek(buf, 4)
		wpoke updateNumber, 0, wpeek(buf, 6)
		dim logFile, 2 : memcpy logFile, buf, 8, 0, 8
		wpoke sequenceNumber, 0, wpeek(buf, 0x10)
		wpoke hardLinkCount, 0, wpeek(buf, 0x12)
		wpoke attributeOffset, 0, wpeek(buf, 0x14)
		wpoke flag, 0, wpeek(buf, 0x16)
		lpoke usedSize, 0, lpeek(buf, 0x18)
		lpoke allocatedSize, 0, lpeek(buf, 0x1c)
		dim baseRecord, 2 : memcpy baseRecord, buf, 8, 0, 0x20
		wpoke nextAttributeID, 0, wpeek(buf, 0x28)
		sdim MFTRecord, allocatedSize : memcpy MFTRecord, buf, allocatedSize, 0, 0	; whole data
		// アップデートシーケンスを修正
		if ( allocatedSize >= GetSectorSize() ) {
			wpoke cmpVal_1, 0, wpeek(buf, updateOffset)
			wpoke cmpVal_2, 0, wpeek(buf, GetSectorSize()-2)
			if ( cmpVal_1 != cmpVal_2 ) : return -1			; 破損
			// 修正
			wpoke MFTRecord, GetSectorSize()-2, wpeek(buf, updateOffset+2)
		}
	return 0
	#modcfunc st_MFTRecord_GET str vname
		ret = 0
		switch(getpath(vname, 16))
			case "signature" : lpoke ret, 0, signature : swbreak
			case "updateoffset" : wpoke ret, 0, updateOffset : swbreak
			case "updatenumber" : wpoke ret, 0, updateNumber : swbreak
			case "logfile" : ret = varptr(logFile) : swbreak				; 8b
			case "sequencenumber" : wpoke ret, 0, sequenceNumber : swbreak
			case "hardlinkcount" : wpoke ret, 0, hardLinkCount : swbreak
			case "attributeoffset" : wpoke ret, 0, attributeOffset : swbreak
			case "flag" : wpoke ret, 0, flag : swbreak
			case "usedsize" : lpoke ret, 0, usedSize : swbreak
			case "allocatedsize" : lpoke ret, 0, allocatedSize : swbreak
			case "baserecord" : ret = varptr(baseRecord) : swbreak			; 8b
			case "nextattributeid" : wpoke ret, 0, nextAttributeID : swbreak
			case "mftrecord" : ret = varptr(MFTRecord) : swbreak			; 1024b
		swend
	return ret
#global

/*--------------------------------------------------
	ノンレジデントアトリビュート構造体
--------------------------------------------------*/
#module st_AttributeNR typeID, len, formCode, nameLength, nameOffset,\
	                         flag, attributeID, startVCN, endVCN, runListOffset,\
	                         compressSize, contentDiskSize, contentSize, initialContentSize
	#modfunc st_AttributeNR_SET var buf
		lpoke typeID, 0, lpeek(buf, 0)
		if ( typeID == 0xffffffff ) : return 1
		lpoke len, 0, lpeek(buf, 4)
		poke formCode, 0, peek(buf, 8)
		poke nameLength, 0, peek(buf, 9)
		wpoke nameOffset, 0, wpeek(buf, 0xA)
		wpoke flag, 0, wpeek(buf, 0xC)
		wpoke attributeID, 0, wpeek(buf, 0xE)
		dim startVCN, 2 : memcpy startVCN, buf, 8, 0, 0x10
		dim endVCN, 2 : memcpy endVCN, buf, 8, 0, 0x18
		wpoke runListOffset, 0, wpeek(buf, 0x20)
		wpoke compressSize, 0, wpeek(buf, 0x22)
		dim contentDiskSize, 2 : memcpy contentDiskSize, buf, 8, 0, 0x28
		dim contentSize, 2 : memcpy contentSize, buf, 8, 0, 0x30
		dim initialContentSize, 2 : memcpy initialContentSize, buf, 8, 0, 0x38
		// アトリビュート全体も保存する
		sdim Attribute, len : memcpy Attribute, buf, len, 0, 0
	return 1
	#modcfunc st_AttributeNR_GET str vname
		ret = 0
		switch(getpath(vname, 16))
			case "typeid" : lpoke ret, 0, typeID : swbreak
			case "len" : lpoke ret, 0, len : swbreak
			case "formcode" : poke ret, 0, formCode : swbreak
			case "namelength" : poke ret, 0, nameLength : swbreak
			case "nameoffset" : wpoke ret, 0, nameOffset : swbreak
			case "flag" : wpoke ret, 0, flag : swbreak
			case "attributeid" : wpoke ret, 0, attributeID : swbreak
			case "startvcn" : ret = varptr(startVCN) : swbreak
			case "endvcn" : ret = varptr(endVCN) : swbreak
			case "runlistoffset" : wpoke ret, 0, runListOffset : swbreak
			case "compresssize" : wpoke ret, 0, compressSize : swbreak
			case "contentdisksize" : ret = varptr(contentDiskSize) : swbreak
			case "contentsize" : ret = varptr(contentSize) : swbreak
			case "initialcontentsize" : ret = varptr(initialContentSize) : swbreak
			case "attribute" : ret = varptr(Attribute) : swbreak
		swend
	return ret
#global

/*--------------------------------------------------
	レジデントアトリビュート構造体
--------------------------------------------------*/
#module st_AttributeR typeID, len, formCode, nameLength, nameOffset,\
	                         flag, attributeID, contentLength, contentOffset,\
	                         indexedFlag, AttributeName, Attribute
	#modfunc st_AttributeR_SET var buf
		lpoke typeID, 0, lpeek(buf, 0)
		if ( typeID == 0xffffffff ) : return 0
		lpoke len, 0, lpeek(buf, 4)
		poke formCode, 0, peek(buf, 8)
		poke nameLength, 0, peek(buf, 9)
		wpoke nameOffset, 0, wpeek(buf, 0xA)
		wpoke flag, 0, wpeek(buf, 0xC)
		wpoke attributeID, 0, wpeek(buf, 0xE)
		lpoke contentLength, 0, lpeek(buf, 0x10)
		wpoke contentOffset, 0, wpeek(buf, 0x14)
		poke indexedFlag, 0, peek(buf, 0x16)
		// Non-residentであれば構造体を変更する
		if ( formCode == 1 ) {
			delmod thismod
			newmod thismod, st_AttributeNR
			st_AttributeNR_SET thismod, buf
			return 1
		}
		// データを取得
		sdim AttributeName, 2*nameLength : memcpy AttributeName, buf, 2*nameLength, 0, 0x18
		sdim Attribute, contentLength : memcpy Attribute, buf, contentLength, 0, 0x18 + 2*nameLength
	return 0
	#modcfunc st_AttributeR_GET str vname
		ret = 0
		switch(getpath(vname, 16))
			case "typeid" : lpoke ret, 0, typeID : swbreak
			case "len" : lpoke ret, 0, len : swbreak
			case "formcode" : poke ret, 0, formCode : swbreak
			case "namelength" : poke ret, 0, nameLength : swbreak
			case "nameoffset" : wpoke ret, 0, nameOffset : swbreak
			case "flag" : wpoke ret, 0, flag : swbreak
			case "attributeid" : wpoke ret, 0, attributeID : swbreak
			case "contentlength" : lpoke ret, 0, contentLength : swbreak
			case "contentoffset" : wpoke ret, 0, contentOffset : swbreak
			case "indexedflag" : poke ret, 0, indexedFlag : swbreak
			case "attributename" : ret = varptr(AttributeName) : swbreak
			case "attribute" : ret = varptr(Attribute) : swbreak
		swend
	return ret
#global

/*--------------------------------------------------
	Data Runs構造体
--------------------------------------------------*/
#module st_DataRuns offset, len
	#modinit var o, var l
		index++
		dim offset, 4 : memcpy offset, o, 16, 0, 0
		dim len, 4 : memcpy len, l, 16, 0, 0
	return
	#modterm
		index--
	return
	#modcfunc st_DataRuns_GET str vname
		ret = 0
		switch getpath(vname, 16)
			case "offset" : ret = varptr(offset) : swbreak
			case "len" : ret = varptr(len) : swbreak
			case "count" : ret = index : swbreak
		swend
	return ret
#global

/*--------------------------------------------------
	NTFS解析モジュール
--------------------------------------------------*/
#module "NTFS_Parser"
	#uselib "kernel32.dll"
		#func JumpTo "SetFilePointer" int, sptr, int, int
		#cfunc ReadFile "ReadFile" int, int, int, int, int
		#cfunc GetLastError "GetLastError"
	// ReadFile
	#const FILE_BEGIN 0
	#const FILE_CURRENT 1
	// misc
	#const INVALID_HANDLE_VALUE -1
	#const NULL 0
	
	/*--------------------------------------------------
	// ParseDataRuns : データリストを解析する
	//    p1 : Data Runs構造体を格納する変数
	//    p3 : $DATAを持つアトリビュート構造体
	//
	//    DataRuns
	//        NAME    SIZE  CONTENTS
	//        Header  1     0xXY => Y byte length, X byte offset
	//        Length  Y     Length(read left to right)
	//        Offset  X     Offset(read right to left)
	--------------------------------------------------*/
	#deffunc ParseDataRuns var stDR, var stAttr
		// non-residentであり、$DATAであるか
		if ( st_AttributeR_GET(stAttr, "formCode") == 0 || st_AttributeNR_GET(stAttr, "typeID") != NTFS_DATA ) : return -1
		ret = 0
		
		// 初期化
		tmp_int = 0
		lenLength = 0 : lenOffset = 0
		drSize = st_AttributeNR_GET(stAttr, "len") - st_AttributeNR_GET(stAttr, "runlistoffset")
		gotByte = 0		; すでに調査したバイト数
		repeat
			if ( drSize <= 0 ) : ret = -1 : break	; broken
			
			// 初期化
			dim len, 4 : dim offset, 4
			sdim DataRuns, drSize
			
			// Runlistsを取得
			dupptr DataRuns, st_AttributeNR_GET(stAttr, "Attribute") + st_AttributeNR_GET(stAttr, "runlistoffset") + gotByte, drSize, 2
			
			// lengthを取得
			poke lenLength, 0, peek(DataRuns, 0) & 0xF	; lengthのlength
			if ( lenLength >= 4 ) : break
			repeat lenLength : len |= peek(DataRuns, 1+cnt) << (cnt*8) : loop
			
			// offsetを取得
			poke lenOffset, 0, peek(DataRuns, 0) >> 4	; offsetのlength
			if ( lenOffset >= 4 ) : break
			repeat lenOffset : offset |= peek(DataRuns, 1+lenLength+cnt) << (cnt*8) : loop
			
			// Data Runs構造体とする
			newmod stDR, st_DataRuns, offset, len
			// 次のData Runへ
			gotByte += 1 + lenLength + lenOffset
			drSize -= gotByte
			
			// 終了チェック
			if ( peek(DataRuns, 1+lenLength+lenOffset) == 0x00 ) : break
		loop
	return ret
	
	/*--------------------------------------------------
	// FindAttribute : アトリビュート情報を取得
	//    p1 : 構造体を格納する変数
	//    p2 : MFTレコード情報(st_MFTRecord構造体)
	//    p3 : 取得するアトリビュートのタイプ(数値)
	--------------------------------------------------*/
	#define global FindAttribute(%1, %2, %3, %4=0) _FindAttribute_ %1, %2, %3, %4
	#deffunc _FindAttribute_ var stAttr, var stMFT, int chk_typeID, int nextAttrOffset_
		nextAttrOffset = nextAttrOffset_	; 最初のアトリビュートから次のアトリビュートまでのオフセット
		ret = -1
		
		// MFT内のアトリビュート全体サイズはallocatedSize - attributeOffset
		attrSize = st_MFTRecord_GET(stMFT, "allocatedSize") - st_MFTRecord_GET(stMFT, "attributeOffset")
		
		repeat
			if ( nextAttrOffset >= attrSize ) : break
			
			// MFTRecordのポインタのattributeOffsetバイト先からコピー
			sdim attrR, attrSize
			dupptr attrR, st_MFTRecord_GET(stMFT, "MFTRecord") + st_MFTRecord_GET(stMFT, "attributeOffset") + nextAttrOffset, attrSize - nextAttrOffset, 2
			
			// データを構造体とする
			newmod stAttr, st_AttributeR
			st_AttributeR_SET stAttr, AttrR
			
			// Non-residentが取得された
			if ( stat == 1 ) {
				typeID = st_AttributeNR_GET(stAttr, "typeID")
				len = st_AttributeNR_GET(stAttr, "len")
				nr = st_AttributeNR_GET(stAttr, "formCode")
			} else {	// Residentが取得された
				typeID = st_AttributeR_GET(stAttr, "typeID")
				len = st_AttributeR_GET(stAttr, "len")
				nr = st_AttributeNR_GET(stAttr, "formCode")
			}
			
			// 次のアトリビュートへ
			nextAttrOffset += len
			
			// アトリビュートが存在しない
			if ( typeID == 0xffffffff ) : break
			
			// 指定の属性IDを発見
			if ( typeID == chk_typeID ) : ret = nextAttrOffset : break
			
			delmod stAttr
		loop
	return ret
	
	/*--------------------------------------------------
	// GetMFTRecord : MFTレコード情報を取得
	//    p1 : デバイスのハンドル
	//    p2 : 格納先の変数
	//    p3 : 前のポインタからのセクタ数を保持するポインタ
	//         (MFT Cluster Numberを保持するポインタ)
	//    p4 : 最初のMFTであるか(単位をクラスタにするか)
	--------------------------------------------------*/
	#deffunc GetMFTRecord int _hDevice, var stMFT, int p_mft_cluster_number, int isFirst
		// ポインタはNTFS Boot Sectorで保持
		
		// MFTへのクラスタを取得
		dupptr addr_l, p_mft_cluster_number, 4, 4
		dupptr addr_u, p_mft_cluster_number + 4, 4, 4
		
		// 単位を設定
		if ( isFirst == 1 ) {
			clusterSize = GetClusterSize()
		} else {
			clusterSize = 1
		}
		
		// ポインタを設定
		repeat clusterSize * GetSectorSize()
			JumpTo _hDevice, addr_l, addr_u, FILE_CURRENT
		loop
		;mes strf("%x", stat)
		
		// 読み込み
		sdim MFT, 0x400
		if ( ReadDevice(_hDevice, MFT, 0x400 / GetSectorSize(), 0) == -1 ) : return -1
		
		// データを構造体とする
		newmod stMFT, st_MFTRecord
		st_MFTRecord_SET stMFT, MFT
		if ( stat == -1 ) : return -1
		
		// ポインタは保持
	return 0
	
	/*--------------------------------------------------
	// GetNTFSBootSector : NTFSブートセクタ情報を取得
	//    p1 : デバイスのハンドル
	//    p2 : 格納先の変数
	//    p3 : NTFS Boot Sectorへの絶対アドレス
	--------------------------------------------------*/
	#deffunc GetNTFSBootSector int _hDevice, var stNBS, int relative_sectors
		// ポインタを0にセット
		JumpTo _hDevice, 0, NULL, FILE_BEGIN
		
		// ブートセクタから0x200バイト取得
		sdim NBS, 0x200
		if ( ReadDevice(_hDevice, NBS, 0x200 / GetSectorSize(), relative_sectors) == -1 ) : return -1
		
		// データを構造体とする
		newmod stNBS, st_NTFSBootSector
		st_NTFSBootSector_SET stNBS, NBS
		
		// セクタサイズとクラスタサイズを設定
		UpdateSectorSize st_NTFSBootSector_GET(stNBS, "bytePerSector")
		UpdateClusterSize st_NTFSBootSector_GET(stNBS, "sectorPerCluster")
		
		// ポインタはNTFSで保持
	return 0
#global
